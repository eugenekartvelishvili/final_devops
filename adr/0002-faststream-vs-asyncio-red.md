# 2. FastStream vs asyncio-red

Date: 2025-12-03

## Status
Accepted

## Context
В рамках итогового задания требуется построить небольшой событийно-ориентированный сервис поверх Redis, 
обернуть его в Docker, настроить healthchecks и провести нагрузочное тестирование.  
При этом важны не только технические детали реализации, но и **воспроизводимость** проекта, удобство сопровождения и читаемость кода для проверяющего.

В качестве кандидатов для работы с Redis в событийной архитектуре рассматривались две библиотеки:

- **asyncio-red** — более низкоуровневая обёртка над Redis, которая даёт гибкий контроль над типами структур (lists, channels, streams), но требует больше ручного кода для настройки продюсеров, консьюмеров, подписчиков и обработки ошибок.
- **FastStream[redis]** — фреймворк более высокого уровня, который предоставляет готовые абстракции publisher/subscriber, интеграцию с Redis и удобное API для публикации и приёма сообщений, ближе по духу к современным event-driven фреймворкам.

Так как цель задания — показать умение собрать **воспроизводимый DevOps-проект**, а не только написать низкоуровневый клиент, важным фактором является:

- скорость понимания кода другим разработчиком/проверяющим;
- простота интеграции с FastAPI и Docker;
- предсказуемое поведение под нагрузкой при минимуме «служебного» кода.

## Decision
В рамках итогового DevOps-проекта в качестве основной библиотеки для работы с Redis выбран **FastStream[redis]**.

Основные аргументы в пользу этого решения:

- FastStream предоставляет **готовый, единообразный интерфейс** для публикации сообщений и подписки на них поверх Redis, что упрощает код сервиса.
- Интеграция с асинхронным Python и FastAPI получается более очевидной: достаточно создать `RedisBroker`, вызвать `broker.start()` на старте приложения и использовать `broker.publish(...)` для отправки событий.
- Код, реализующий бизнес-логику (эндпоинты `/health` и `/produce`), остаётся компактным и легко читаемым, что важно для учебного проекта и для проверки в рамках дисциплины.
- За счёт более высокого уровня абстракции уменьшается количество шаблонного и боулерплейт-кода, что снижает риск ошибок при ручном управлении соединениями и пайплайнами Redis.

При этом asyncio-red рассматривается как альтернативная реализация, но в данном проекте она **не выбрана** в качестве основной.

## Consequences
Положительные последствия выбора FastStream[redis]:

- **Ускорение разработки**: меньше времени тратится на написание низкоуровневого кода, больше — на настройку инфраструктуры, Docker и нагрузочного тестирования, что соответствует целям DevOps-задания.
- **Более читаемый код**: проверяющему легко понять, где публикуются события, как устроен healthcheck и как сервис взаимодействует с Redis.
- **Лучшее соответствие учебным целям**: проект демонстрирует не только работу с Redis, но и использование современного фреймворка для event-driven архитектуры, что ближе к реальным продакшен-подходам.
- **Проще поддерживать и расширять**: при необходимости можно добавить подписчиков, обработчики сообщений или логирование брокера без существенной переработки структуры приложения.

Отрицательные и потенциальные риски:

- **Дополнительная зависимость от фреймворка**: проект сильнее завязан на FastStream, а не на «чистый» Redis-клиент. При смене библиотеки потребуется переписывать часть кода.
- **Меньший контроль над низкоуровневой логикой**: некоторые детали работы с Redis скрыты во внутренней реализации FastStream, что может быть минусом, если нужны очень специфические настройки.
- **Кривая обучения**: для разработчиков, незнакомых с FastStream, потребуется время на понимание концепции брокера и его жизненного цикла (подключение/отключение).

Обоснование отказа от asyncio-red в данном проекте:

- asyncio-red хорошо подходит для минималистичных скриптов и ситуаций, когда нужен максимально тонкий контроль над Redis-структурами и сериализацией.
- Однако в рамках данного учебного задания это привело бы к большему количеству инфраструктурного кода и отвлекло бы от основной цели — продемонстрировать **воспроизводимый DevOps-подход** с контейнеризацией, healthchecks и нагрузочным тестированием.